# Хуки

Что такое хук и зачем он нужен? Хуки — это **функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов**.  Стоит заметить, что хуки не работают в классовых компонентах. 
С помощью хуков можно написать краткий, лаконичный и более понятный код. И это главное их преимущество. Их использование позволяет изменять любую из функций без необходимости переписывать код целиком. Они улучшают структуру кода и его читабельность.
## useState
Хук **useState** используется для того, чтобы наделить наш функциональный компонент внутренним состоянием.

Пример

   ``` js
const Example = (props) => {
	const [count, setCount] = useState(0);  
	return <div />;
}
```

**Что происходит когда мы вызываем `useState()`**

 1.  `useState()` объявляет переменную состояния, в нашем примере это `count`. Эта переменная нужна для сохранения значения между вызовами функции. 
`Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не относится, потому что их сохраняет React.`
2.  Единственно возможный аргумент `useState()` записывается как начальное сотояние в `count`.
3.  Возвращает пару значений: текущее состояние и функцию, обновляющую состояние. Поэтому мы пишем `const [count, setCount] = useState()`.

***В кратце, что делает `useState()` в нашем примере***
Мы объявляем переменную состояния `count` и устанавливаем ей значение `0`. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить `count`, мы вызовем `setCount`.

Второе значение `setCount`, возвращаемое хуком `useState()` - функция, которую мы используем для обновления состояния.

Обратите внимание, что, в отличие от `this.setState` в классах, обновление переменной состояния всегда _замещает_ её значение, а не осуществляет слияние.

## useEffect
Хук `useEffect` даёт вам возможность выполнять побочные эффекты в функциональном компоненте. Он представляет собой совокупность методов `componentDidMount`, `componentDidUpdate`, и `componentWillUnmount`.

`useEffect` принимает функцию(эффект), React запонмнит эту функцию и вызовет её после того, как внесёт все изменения в DOM.

**Существует два распространённых вида побочных эффектов в компонентах React:**

### Эффекты без сброса

Пример 

   ```js
import React, { useState, useEffect } from 'react';
function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {    
	  document.title = `Вы нажали ${count} раз`;
  });
  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
```

**Почему же мы вызываем  `useEffect`  непосредственно внутри компонента?** Это даёт нам доступ к переменной состояния `count` (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.

Также, стоит отметить что функция, которую мы передаём в `useEffect`, будет меняться при каждом рендере. На самом деле, это было сделано преднамеренно. Это как раз то, что даёт нам возможность получать актуальную версию переменной `count` изнутри эффекта, не беспокоясь о том, что её значение устареет. Каждый раз при повторном рендере, мы ставим в очередь _новый_ эффект, который заменяет предыдущий. В каком-то смысле, это включает поведение эффектов как часть результата рендера, то есть каждый эффект «принадлежит» определённому рендеру.

***Заметьте***
В отличие от `componentDidMount`  или  `componentDidUpdate`, эффекты, запланированные с помощью  `useEffect`, не блокируют браузер при попытке обновить экран. Ваше приложение будет быстрее реагировать на действия пользователя, даже когда эффект ещё не закончился. Большинству эффектов не нужно работать в синхронном режиме. Есть редкие случаи, когда им всё же нужно это делать (например, измерять раскладку), но для этого есть специальный хук `useLayoutEffect`.

### Эффекты со сбросом

Ранее мы рассмотрели побочные эффекты, которые не требуют сброса. Однако, есть случаи, когда сброс всё же необходим. Например, **нам может потребоваться установить подписку** на какой-нибудь внешний источник данных. В этом случае очень важно выполнять сброс, чтобы не случилось утечек памяти!

Пример
```js
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
	function handleStatusChange(status) {
		setIsOnline(status.isOnline);
	}
	ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
	return function cleanup() {	
		ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
	};
  });
  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}
```
**Зачем мы вернули функцию из нашего эффекта?** Это необязательный механизм сброса эффектов. Каждый эффект может возвратить функцию, которая сбросит его. Это даёт нам возможность объединить вместе логику оформления и отмены подписки. Они, всё-таки, часть одного и того же эффекта!
**Когда именно React будет сбрасывать эффект?** React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React _также_ сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.

## Правила хуков

### Используйте хуки только на верхнем уровне
**Не вызывайте хуки внутри циклов, условных операторов или вложенных функций.** Вместо этого всегда используйте хуки только внутри React-функций, до возврата какого-либо значения из них. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами `useState` и `useEffect`.
### Вызывайте хуки только из React-функций

**Не вызывайте хуки из обычных функций JavaScript.**  Вместо этого можно:

-    Вызывать хуки из функционального компонента React.
-   Вызывать хуки из пользовательского хука
 
Следуя этому правилу, можно гарантировать, что вся логика состояния компонента чётко видна из исходного кода.
### Объяснения 
Если хуки состояния или эффектов в одном и том же компоненте можно использовать многократно, то как же React сопоставляет переменные состояния с вызовами `useState`? Ответ таков: **React полагается на порядок вызова хуков**.

До тех пор пока порядок вызова хуков одинаков в каждом рендере, React может сопоставить некое внутреннее состояние с каждым из них. Но что случится, если мы поместим вызов какого-нибудь хука внутрь условного оператора?

Если условие выполняется при первом рендере, то хук выполнится. Но что случится, если пользоваель обратит условие в `false`? Тогда во время рендера хук будет пропущен и порядок вызовов хуков изменится.

React не будет знать, что вернуть для второго вызова этого хука. React ожидал, что второй вызов хука в этом компоненте соответствует какому-то эффекту, так же как при предыдущем рендере, но это больше не так. Начиная с этого момента, вызов каждого хука, следующего за пропущенным, также будет сдвинут на один назад, что приведёт к ошибкам. **Именно поэтому хуки должны вызываться на верхнем уровне компонента.**